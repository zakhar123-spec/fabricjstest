<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>DART Sim Rhythm Tool</title>
<!-- Font Awesome CDN -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/460/fabric.min.js" integrity="sha512-ybPp3kCrNQXdvTfh99YLIdnajWnQvHuEKDJ+b26mxI9w+pLhnBo3HmNLJ1pEUBFO1Q0bfJxApeqecNbmaV763g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  h1 {
    text-align: center;
    margin: 10px 0;
  }
  /* Controls styling */
  .controls {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
  }
  /* Tool buttons */
  .tool-btn {
    background: #f0f0f0;
    border: none;
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 4px;
    font-size: 1.2em;
  }
  .tool-btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }
  /* Slider & color picker */
  .slider-container {
    display: flex;
    align-items: center;
  }
  /* Canvas container */
  #canvas-container {
    border: 1px solid #ccc;
    width: 250px;
    height: 200px;
    margin-bottom: 10px;
  }
  canvas {
    width: 100%;
    height: 100%;
  }
  /* Download menu */
  .download-menu {
    position: relative;
    display: inline-block;
  }
  .download-btn {
    background: #4CAF50;
    color: white;
    padding: 8px 12px;
    border: none;
    cursor: pointer;
    border-radius: 4px;
  }
  .download-options {
    display: none;
    position: absolute;
    background-color: #f9f9f9;
    min-width: 120px;
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    z-index: 1;
  }
  .download-options button {
    background-color: #f1f1f1;
    border: none;
    padding: 8px 12px;
    width: 100%;
    text-align: left;
    cursor: pointer;
  }
  .download-options button:hover {
    background-color: #ddd;
  }
  .download-menu:hover .download-options {
    display: block;
  }
</style>
</head>
<body>

<h1>Fabric.js Drawing App</h1>

<div class="controls">
  <!-- Tool Buttons -->
  <button class="tool-btn" id="selectBtn" title="Select" aria-label="Select">
    <i class="fas fa-mouse-pointer"></i>
  </button>
  <button class="tool-btn" id="pencilBtn" title="Pencil" aria-label="Pencil">
    <i class="fas fa-pencil-alt"></i>
  </button>
  <button class="tool-btn" id="penBtn" title="Pen" aria-label="Pen">
    <i class="fas fa-pen"></i>
  </button>
  <button class="tool-btn" id="lineBtn" title="Line" aria-label="Line">
    <i class="fas fa-minus"></i>
  </button>
  <button class="tool-btn" id="eraserBtn" title="Eraser" aria-label="Eraser">
    <i class="fas fa-eraser"></i>
  </button>
  <!-- Undo / Redo -->
  <button class="tool-btn" id="undoBtn" title="Undo" aria-label="Undo" disabled>
    <i class="fas fa-undo"></i>
  </button>
  <button class="tool-btn" id="redoBtn" title="Redo" aria-label="Redo" disabled>
    <i class="fas fa-redo"></i>
  </button>
  <!-- Select All -->
  <button class="tool-btn" id="selectAllBtn" title="Select All" aria-label="Select All">
    <i class="fas fa-square-full"></i>
  </button>
  <!-- Lock / Delete -->
  <button class="tool-btn" id="lockObjBtn" title="Lock/Unlock Object" aria-label="Lock/Unlock Object">
    <i class="fas fa-lock"></i>
  </button>
  <button class="tool-btn" id="deleteObjBtn" title="Delete Object" aria-label="Delete Object">
    <i class="fas fa-trash"></i>
  </button>
  <!-- Zoom In / Out / Reset -->
  <button class="tool-btn" id="zoomInBtn" title="Zoom In" aria-label="Zoom In">
    <i class="fas fa-search-plus"></i>
  </button>
  <button class="tool-btn" id="zoomOutBtn" title="Zoom Out" aria-label="Zoom Out">
    <i class="fas fa-search-minus"></i>
  </button>
  <button class="tool-btn" id="resetBtn" title="Reset View" aria-label="Reset View">
    <i class="fas fa-sync-alt"></i>
  </button>
  <!-- Stroke Thickness Slider -->
  <div class="slider-container">
    <label for="thicknessRange">Thickness: </label>
    <input type="range" id="thicknessRange" min="1" max="20" value="2" />
  </div>
  <!-- Color Picker -->
  <input type="color" id="colorPicker" value="#000000" title="Pick Color" />
  <!-- Upload Image -->
  <button class="tool-btn" id="uploadImageBtn" title="Upload Image" aria-label="Upload Image">
    <i class="fas fa-upload"></i>
  </button>
  <input type="file" id="imageUpload" accept="image/*" style="display:none" />
  <!-- Download Dropdown -->
  <div class="download-menu">
    <button class="tool-btn"><i class="fas fa-caret-down"></i></button>
    <div class="download-options">
      <button data-type="svg">SVG</button>
      <button data-type="png">PNG</button>
      <button data-type="jpeg">JPG</button>
      <button data-type="json">JSON</button>
    </div>
  </div>
</div>

<!-- Canvas Container -->
<div id="canvas-container">
  <canvas id="drawingCanvas" width="250" height="200"></canvas>
</div>

<script>
  // Initialize Fabric.js Canvas
  const canvas = new fabric.Canvas('drawingCanvas', {
    preserveObjectStacking: true,
    isDrawingMode: true
  });
  let ctx = canvas.getContext('2d');
  // Set Canvas Size
  const container = document.getElementById('canvas-container');
  const width = 250;
  const height = 200;
  canvas.setWidth(width);
  canvas.setHeight(height);
  
  // Centered Title - already done via CSS
  
  // Tool State
  let currentTool = 'select'; // options: select, pencil, pen, line, eraser
  let isDrawing = false;
  let currentLine = null;
  let startX = 0;
  let startY = 0;
  let undoStack = [];
  let redoStack = [];
  let isObjectLocked = false;
  
  // Get UI Elements
  const selectBtn = document.getElementById('selectBtn');
  const pencilBtn = document.getElementById('pencilBtn');
  const penBtn = document.getElementById('penBtn');
  const lineBtn = document.getElementById('lineBtn');
  const eraserBtn = document.getElementById('eraserBtn');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const selectAllBtn = document.getElementById('selectAllBtn');
  const lockObjBtn = document.getElementById('lockObjBtn');
  const deleteObjBtn = document.getElementById('deleteObjBtn');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const resetBtn = document.getElementById('resetBtn');
  const thicknessRange = document.getElementById('thicknessRange');
  const colorPicker = document.getElementById('colorPicker');
  const uploadImageBtn = document.getElementById('uploadImageBtn');
  const imageUpload = document.getElementById('imageUpload');
  const downloadButtons = document.querySelectorAll('.download-options button');

  // Set default stroke width and color
  let strokeWidth = parseInt(thicknessRange.value);
  let strokeColor = colorPicker.value;

  // Helper functions
  function saveState() {
    // Save current canvas state for undo
    const json = JSON.stringify(canvas);
    undoStack.push(json);
    // Clear redo stack
    redoStack = [];
    updateUndoRedoButtons();
  }

  function undo() {
    if (undoStack.length > 0) {
      const lastState = undoStack.pop();
      redoStack.push(JSON.stringify(canvas));
      canvas.loadFromJSON(lastState, () => {
        canvas.renderAll();
        updateUndoRedoButtons();
      });
    }
  }

  function redo() {
    if (redoStack.length > 0) {
      const state = redoStack.pop();
      undoStack.push(JSON.stringify(canvas));
      canvas.loadFromJSON(state, () => {
        canvas.renderAll();
        updateUndoRedoButtons();
      });
    }
  }

  function updateUndoRedoButtons() {
    undoBtn.disabled = undoStack.length === 0;
    redoBtn.disabled = redoStack.length === 0;
  }

  function setActiveTool(tool) {
    currentTool = tool;
    // Update button states
    document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
    switch(tool) {
      case 'select':
        selectBtn.classList.add('active');
        canvas.isDrawingMode = false;
        break;
      case 'pencil':
        pencilBtn.classList.add('active');
        canvas.isDrawingMode = true;
        canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
        canvas.freeDrawingBrush.width = strokeWidth;
        canvas.freeDrawingBrush.color = strokeColor;
        break;
      case 'pen':
        penBtn.classList.add('active');
        canvas.isDrawingMode = true;
        canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
        canvas.freeDrawingBrush.width = strokeWidth;
        canvas.freeDrawingBrush.color = strokeColor;
        break;
      case 'line':
        lineBtn.classList.add('active');
        canvas.isDrawingMode = false;
        break;
      case 'eraser':
        eraserBtn.classList.add('active');
        canvas.isDrawingMode = false;
        break;
    }
  }

  // Initialize default tool
  setActiveTool('select');

  // Event Listeners for Tool Buttons
  selectBtn.addEventListener('click', () => setActiveTool('select'));
  pencilBtn.addEventListener('click', () => setActiveTool('pencil'));
  penBtn.addEventListener('click', () => setActiveTool('pen'));
  lineBtn.addEventListener('click', () => setActiveTool('line'));
  eraserBtn.addEventListener('click', () => setActiveTool('eraser'));

  // Undo/Redo
  document.getElementById('undoBtn').addEventListener('click', undo);
  document.getElementById('redoBtn').addEventListener('click', redo);
  updateUndoRedoButtons();

  // Select All
  document.getElementById('selectAllBtn').addEventListener('click', () => {
    canvas.discardActiveObject();
    const sel = new fabric.ActiveSelection(canvas.getObjects(), {
      canvas: canvas,
    });
    canvas.setActiveObject(sel);
    canvas.requestRenderAll();
  });

  // Lock / Unlock Object
  document.getElementById('lockObjBtn').addEventListener('click', () => {
    const activeObj = canvas.getActiveObject();
    if (activeObj) {
      activeObj.selectable = !activeObj.selectable;
      activeObj.lockMovementX = !activeObj.lockMovementX;
      activeObj.lockMovementY = !activeObj.lockMovementY;
      activeObj.hasControls = activeObj.selectable;
      canvas.requestRenderAll();
    }
  });

  // Delete Object
  document.getElementById('deleteObjBtn').addEventListener('click', () => {
    const activeObj = canvas.getActiveObject();
    if (activeObj) {
      saveState();
      canvas.remove(activeObj);
    }
  });

  // Zoom In / Out / Reset
  let zoomFactor = 1;
  document.getElementById('zoomInBtn').addEventListener('click', () => {
    zoomFactor *= 1.2;
    canvas.setZoom(zoomFactor);
  });
  document.getElementById('zoomOutBtn').addEventListener('click', () => {
    zoomFactor /= 1.2;
    if (zoomFactor < 0.2) zoomFactor = 0.2;
    canvas.setZoom(zoomFactor);
  });
  document.getElementById('resetBtn').addEventListener('click', () => {
    zoomFactor = 1;
    canvas.setZoom(zoomFactor);
    canvas.viewportTransform = [1, 0, 0, 1, 0, 0];
  });

  // Thickness Slider
  document.getElementById('thicknessRange').addEventListener('input', (e) => {
    strokeWidth = parseInt(e.target.value);
    if (canvas.freeDrawingBrush) {
      canvas.freeDrawingBrush.width = strokeWidth;
    }
  });

  // Color Picker
  document.getElementById('colorPicker').addEventListener('change', (e) => {
    strokeColor = e.target.value;
    if (canvas.freeDrawingBrush) {
      canvas.freeDrawingBrush.color = strokeColor;
    }
  });

  // Upload Image
  document.getElementById('uploadImageBtn').addEventListener('click', () => {
    document.getElementById('imageUpload').click();
  });

  document.getElementById('imageUpload').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = function(f) {
        fabric.Image.fromURL(f.target.result, (img) => {
          saveState();
          img.set({
            left: 50,
            top: 50,
            scaleX: 0.5,
            scaleY: 0.5,
            selectable: true
          });
          canvas.add(img);
        });
      };
      reader.readAsDataURL(file);
    }
  });

  // Download options
  downloadButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const type = btn.getAttribute('data-type');
      saveState(); // Save state before export
      if (type === 'svg') {
        const svg = canvas.toSVG();
        const blob = new Blob([svg], {type: 'image/svg+xml'});
        const url = URL.createObjectURL(blob);
        triggerDownload(url, 'drawing.svg');
      } else if (type === 'png') {
        canvas.deactivateAll().renderAll();
        const dataURL = canvas.toDataURL({format: 'png'});
        triggerDownload(dataURL, 'drawing.png');
      } else if (type === 'jpeg') {
        canvas.deactivateAll().renderAll();
        const dataURL = canvas.toDataURL({format: 'jpeg'});
        triggerDownload(dataURL, 'drawing.jpg');
      } else if (type === 'json') {
        const json = JSON.stringify(canvas.toJSON());
        const blob = new Blob([json], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        triggerDownload(url, 'drawing.json');
      }
    });
  });

  function triggerDownload(url, filename) {
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
  }

  // Canvas Drawing Logic
  // For drawing shapes like lines and freehand
  canvas.on('mouse:down', (opt) => {
    if (currentTool === 'line') {
      isDrawing = true;
      const pointer = canvas.getPointer(opt.e);
      startX = pointer.x;
      startY = pointer.y;
      currentLine = new fabric.Line([startX, startY, startX, startY], {
        stroke: strokeColor,
        strokeWidth: strokeWidth,
        selectable: false,
        evented: false,
      });
      canvas.add(currentLine);
    } else if (currentTool === 'eraser') {
      isDrawing = true;
      saveState();
    }
  });

  canvas.on('mouse:move', (opt) => {
    if (!isDrawing) return;
    if (currentTool === 'line') {
      const pointer = canvas.getPointer(opt.e);
      currentLine.set({ x2: pointer.x, y2: pointer.y });
      canvas.requestRenderAll();
    } else if (currentTool === 'eraser') {
      const pointer = canvas.getPointer(opt.e);
      // Eraser: delete objects under pointer or delete path
      const objs = canvas.getObjects();
      for (let i = objs.length -1; i >=0; i--) {
        if (objs[i].containsPoint && objs[i].containsPoint({x: pointer.x, y: pointer.y})) {
          // Remove object if under pointer
          canvas.remove(objs[i]);
        } else if (objs[i].type === 'path') {
          // For freehand paths, check proximity
          // For simplicity, delete paths close to pointer
          const pathPoints = objs[i].path;
          for (const p of pathPoints) {
            if (Math.hypot(p.x - pointer.x, p.y - pointer.y) < strokeWidth) {
              canvas.remove(objs[i]);
              break;
            }
          }
        }
      }
      canvas.requestRenderAll();
    }
  });

  canvas.on('mouse:up', (opt) => {
    if (currentTool === 'line' && isDrawing) {
      isDrawing = false;
      saveState();
      currentLine.set({ selectable: true, evented: true });
      currentLine = null;
    } else if (currentTool === 'eraser') {
      isDrawing = false;
    }
  });

  // For free drawing (pencil, pen)
  canvas.on('path:created', () => {
    saveState();
  });

  // Set freeDrawingBrush for pencil and pen
  function setDrawingTool() {
    if (currentTool === 'pencil' || currentTool === 'pen') {
      canvas.isDrawingMode = true;
      if (canvas.freeDrawingBrush) {
        canvas.freeDrawingBrush.width = strokeWidth;
        canvas.freeDrawingBrush.color = strokeColor;
      } else {
        canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
        canvas.freeDrawingBrush.width = strokeWidth;
        canvas.freeDrawingBrush.color = strokeColor;
      }
    } else {
      canvas.isDrawingMode = false;
    }
  }

  // Re-apply drawing mode when tools change
  ['pencil', 'pen'].forEach(tool => {
    document.getElementById(tool + 'Btn').addEventListener('click', () => {
      setActiveTool(tool);
      setDrawingTool();
    });
  });

  // When stroke width or color change, update brush
  thicknessRange.addEventListener('input', () => {
    strokeWidth = parseInt(thicknessRange.value);
    if (canvas.freeDrawingBrush) {
      canvas.freeDrawingBrush.width = strokeWidth;
    }
  });
  colorPicker.addEventListener('change', () => {
    strokeColor = colorPicker.value;
    if (canvas.freeDrawingBrush) {
      canvas.freeDrawingBrush.color = strokeColor;
    }
  });

  // Tool buttons event
  document.getElementById('selectBtn').addEventListener('click', () => {
    setActiveTool('select');
    canvas.isDrawingMode = false;
  });
  document.getElementById('lineBtn').addEventListener('click', () => {
    setActiveTool('line');
  });
  document.getElementById('eraserBtn').addEventListener('click', () => {
    setActiveTool('eraser');
  });

  // Lock/Unlock Object
  document.getElementById('lockObjBtn').addEventListener('click', () => {
    const activeObj = canvas.getActiveObject();
    if (activeObj) {
      activeObj.lockMovementX = !activeObj.lockMovementX;
      activeObj.lockMovementY = !activeObj.lockMovementY;
      activeObj.selectable = !activeObj.selectable;
      canvas.requestRenderAll();
    }
  });

  // Select Object
  canvas.on('selection:created', () => {
    // Optional: update UI
  });

  // For better UX, deselect on click on empty space
  canvas.on('mouse:down', (opt) => {
    if (!opt.target) {
      canvas.discardActiveObject();
      canvas.requestRenderAll();
    }
  });

</script>
</body>
</html>